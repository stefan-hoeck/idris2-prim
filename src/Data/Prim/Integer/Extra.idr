||| Additional utilites for solving and deriving
||| (in)equalities in `Integer` arithmetics.
module Data.Prim.Integer.Extra

-- --------------------------------------------------------------------------------
-- --          Addition in Inequalities
-- --------------------------------------------------------------------------------
--
--
-- export
-- 0 plusOneLTE : {x,y : Integer} -> x < y -> x + 1 <= y
-- plusOneLTE lt = App (oneAfterZero (y - x) (minusLT lt)) $
--   |> 1     <= y - x
--   <> x + 1 <= x + (y - x) ... plusLeft
--   <> x + 1 <= y           ..= solve [x,y] (x .+ (y .-. x)) (var y)
--
-- --------------------------------------------------------------------------------
-- --          Division
-- --------------------------------------------------------------------------------
--
-- export
-- 0 multDivP1 : {n,d : Integer} -> (0 < d) -> d * (div n d + 1) > n
-- multDivP1 dpos = App (snd $ modLT n d dpos) $
--   |> mod n d               < d
--   <> d * div n d + mod n d < d * div n d + d ... plusLeft
--   <> n < d * (div n d + 1)                   =.= (
--        lawDivMod n d %search
--      , solve [n,d,div n d] (d .*. div n d +. d)
--                            (d .* (div n d .+ 1))
--      )
--
-- export
-- 0 multDiv : {n,d : Integer} -> (0 < d) -> d * div n d <= n
-- multDiv dpos = App (fst $ modLT n d dpos) $
--   |> 0 <= mod n d
--   <> d * div n d + 0 <= d * div n d + mod n d ... plusLeft
--   <> d * div n d     <= n                     =.= (
--        plusZeroRightNeutral
--      , lawDivMod n d %search
--      )
--
-- export
-- 0 divNonNeg : {n,d : Integer} -> (0 <= n) -> (0 < d) -> 0 <= div n d
-- divNonNeg ngte0 dpos = App (trans_GT_GTE (multDivP1 dpos) ngte0) $
--   |> 0     <  d * (div n d + 1)
--   <> 0     <  div n d + 1       ... solveMultPosLeftZero dpos
--   <> 1     <= div n d + 1       ... (\_ => oneAfterZero _)
--   <> 0     <= div n d           ... solvePlusRightSelf
--
-- export
-- 0 modLTE : {n,d : Integer} -> (0 <= n) -> (0 < d) -> mod n d <= n
-- modLTE ngte0 dpos = App (divNonNeg ngte0 dpos) $
--   |> 0               <= div n d
--   <> d * 0           <= d * div n d           ... multPosLeft dpos
--   <> d * 0 + mod n d <= d * div n d + mod n d ... plusRight
--   <> mod n d         <= n                     =.= (
--        solve [d, mod n d] (d .* 0 +. mod n d) (var (mod n d))
--      , lawDivMod n d %search
--      )
--
-- export
-- 0 modOneIsZero : {n : Integer} -> mod n 1 === 0
-- modOneIsZero = assert_total $ case comp (mod n 1) 0 of
--   EQ _ p _ => p
--   LT p _ _ => void (LT_not_GTE p $ fst $ modLT n 1 %search)
--   GT _ _ p => void (LT_not_GTE (snd $ modLT n 1 %search) (oneAfterZero _ p))
--
-- export
-- 0 divOneSame : {n : Integer} -> div n 1 === n
-- divOneSame = assert_total $ Calc $
--   |~ div n 1
--   ~~ 1 * div n 1           ..< multOneLeftNeutral
--   ~~ 1 * div n 1 + 0       ..< plusZeroRightNeutral
--   ~~ 1 * div n 1 + mod n 1 ..< cong (1 * div n 1 +) modOneIsZero
--   ~~ n                     ... lawDivMod n 1 %search
--
-- export
-- 0 divGreaterOneLT : {n,d : Integer} -> 0 < n -> 1 < d -> div n d < n
-- divGreaterOneLT npos dgt1 =
--   let dpos = the (0 < d) $ trans %search dgt1
--    in assert_total $ case comp 0 (div n d) of
--        EQ _ p _ => replace {p = (< n)} p npos
--        LT p _ _ => App dgt1 $
--          |> 1 < d
--          <> 1 * div n d < d * div n d ... multPosRight p
--          <> div n d     < d * div n d =.. multOneLeftNeutral
--          <> div n d     < n           ... (\_ => trans_GTE_GT $ multDiv dpos)
--        GT _ _ p => void (LT_not_GTE p $ divNonNeg %search dpos)
--
-- export
-- 0 divPos : {n,d : Integer} -> (d <= n) -> (0 < d) -> 0 < div n d
-- divPos dn dp = assert_total $ case comp 0 (div n d) of
--   LT p _ _ => p
--   EQ _ p _ =>
--     let modIsN = Calc $
--           |~ mod n d
--           ~~ 0 + mod n d             ..< plusZeroLeftNeutral
--           ~~ (d * 0) + mod n d       ..< cong (+ mod n d) multZeroRightAbsorbs
--           ~~ (d * div n d) + mod n d ... cong (\x => (d * x) + mod n d) p
--           ~~ n                       ... lawDivMod n d (Right dp)
--      in void (LTE_not_GT dn $ rewrite sym modIsN in snd (modLT n d dp))
--   GT _ _ p => void (GT_not_LTE p (divNonNeg (Left $ trans_LT_LTE dp dn) dp))
