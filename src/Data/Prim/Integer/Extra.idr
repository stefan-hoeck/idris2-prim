||| Additional utilites for solving and deriving
||| (in)equalities in `Integer` arithmetics.
module Data.Prim.Integer.Extra

-- --------------------------------------------------------------------------------
-- --          Addition in Inequalities
-- --------------------------------------------------------------------------------
--
--
-- export
-- 0 plusOneLTE : {x,y : Integer} -> x < y -> x + 1 <= y
-- plusOneLTE lt = App (oneAfterZero (y - x) (minusLT lt)) $
--   |> 1     <= y - x
--   <> x + 1 <= x + (y - x) ... plusLeft
--   <> x + 1 <= y           ..= solve [x,y] (x .+ (y .-. x)) (var y)
--
-- --------------------------------------------------------------------------------
-- --          Multiplication in Inequalities
-- --------------------------------------------------------------------------------
--
-- ||| Multiplication with a negative number reverses an inequality.
-- |||
-- ||| ```idris example
-- ||| |> x     < y
-- ||| <> z * y < z * x ... multNegLeft zgt0
-- ||| ```
-- |||
-- ||| ```idris example
-- ||| |> x     <= y
-- ||| <> z * y <= z * x ... multNegLeft zgt0
-- ||| ```
-- export
-- 0 multNegLeft :  {x,y,z : Integer}
--               -> z < 0
--               -> Rel r (z * y) (z * x)
--               -> r x y
--               -> r (z * y) (z * x)
-- multNegLeft p r =
--   let negp = negateZero (negate z > 0) p
--    in |> rel r x y
--       <> rel r (negate y) (negate x)                 ... negate
--       <> rel r (negate z * negate y) (negate z * negate x) ... multPosLeft negp
--       <> rel r (z * y) (z * x)                 =.= (
--            solve [z,y] (negate (var z) * negate (var y)) (z .*. y)
--          , solve [z,x] (negate (var z) * negate (var x)) (z .*. x)
--          )
--
-- ||| Multiplication with a negative number reverses an inequality.
-- |||
-- ||| ```idris example
-- ||| |> x     < y
-- ||| <> y * z < x * z ... multNegRight zgt0
-- ||| ```
-- |||
-- ||| ```idris example
-- ||| |> x     <= y
-- ||| <> y * z <= x * z ... multNegRight zgt0
-- ||| ```
-- export
-- 0 multNegRight :  {x,y,z : Integer}
--                -> z < 0
--                -> Rel r (y * z) (x * z)
--                -> r x y
--                -> r (y * z) (x * z)
-- multNegRight p r =
--   |> rel r x y
--   <> rel r (z * y) (z * x) ... multNegLeft p
--   <> rel r (y * z) (x * z) =.= pairMultCommutative
--
-- 0 lemmaMult0 : {x,y,z : Integer} -> 0 === z -> x * z === y * z
-- lemmaMult0 prf = Calc $
--   |~ x * z
--   ~~ x * 0 ..< cong (x *) prf
--   ~~ 0     ... multZeroRightAbsorbs
--   ~~ y * 0 ..< multZeroRightAbsorbs
--   ~~ y * z ... cong (y *) prf
--
-- ||| Multiplication with a non-positive number weakens and
-- ||| reverses an inequality.
-- |||
-- ||| ```idris example
-- ||| |> x     <  y
-- ||| <> y * z <= x * z ... multNonPosRight zgte0
-- ||| ```
-- export
-- 0 multNonPosRight :  {x,y,z : Integer}
--                   -> z <= 0
--                   -> Rel (<=) (y * z) (x * z)
--                   -> x < y
--                   -> y * z <= x * z
-- multNonPosRight (Left p) r xy = Left $ multNegRight p (y * z < x * z) xy
-- multNonPosRight (Right p) r xy = Right $ lemmaMult0 (sym p)
--
-- ||| Multiplication with a non-positive number weakens and
-- ||| reverses an inequality.
-- |||
-- ||| ```idris example
-- ||| |> x     <  y
-- ||| <> z * y <= z * x ... multNonPosLeft zlte0
-- ||| ```
-- export
-- 0 multNonPosLeft :  {x,y,z : Integer}
--                  -> z <= 0
--                  -> Rel (<=) (z * y) (z * x)
--                  -> x < y
--                  -> z * y <= z * x
-- multNonPosLeft p r =
--   |> x < y
--   <> y * z <= x * z ... multNonPosRight p
--   <> z * y <= z * x =.= pairMultCommutative
--
-- 0 smpLemma1 : {d,x,y : Integer} -> 0 < d -> d * x < d * y -> x < y
-- smpLemma1 dpos lt = case comp x y of
--   LT p _ _ => p
--   EQ _ p _ => void (EQ_not_LT (cong (d *) p) lt)
--   GT _ _ p => void (GT_not_LT (multPosLeft dpos (d * x > d * y) p) lt)
--
-- 0 smpLemma2 : {d,x,y : Integer} -> 0 < d -> d * x === d * y -> x === y
-- smpLemma2 dpos lt = case comp x y of
--   LT p _ _ => void (LT_not_EQ (multPosLeft dpos (d * x < d * y) p) lt)
--   EQ _ p _ => p
--   GT _ _ p => void (GT_not_EQ (multPosLeft dpos (d * x > d * y) p) lt)
--
-- ||| We can solve (in)equalities, where both sides have
-- ||| been multiplied with the same negative value.
-- |||
-- ||| ```idris example
-- ||| |> z * x < z * y
-- ||| <> y     < x     ... solveMultNegLeft zlt0
-- ||| ```
-- export
-- 0 solveMultNegLeft :  {d,x,y : Integer}
--                    -> d < 0
--                    -> Rel r y x
--                    -> r (d * x) (d * y)
--                    -> r y x
-- solveMultNegLeft dneg r =
--   let negdPos = negateZero (negate d > 0) dneg
--    in |> rel r (d * x) (d * y)
--       <> rel r (negate (d * y)) (negate (d * x)) ... negate
--       <> rel r (negate d * y) (negate d * x)     =.= (
--            solve [d,y] (negate (d .*. y)) (negate (var d) *. y)
--          , solve [d,x] (negate (d .*. x)) (negate (var d) *. x)
--          )
--       <> rel r y x ... solveMultPosLeft negdPos
--
-- ||| We can solve (in)equalities, where both sides have
-- ||| been multiplied with the same negative value.
-- |||
-- ||| ```idris example
-- ||| |> x * z < y * z
-- ||| <> y     < y     ... solveMultNegLeft zlt0
-- ||| ```
-- export
-- 0 solveMultNegRight :  {x,y,d : Integer}
--                     -> d < 0
--                     -> Rel r y x
--                     -> r (x * d) (y * d)
--                     -> r y x
-- solveMultNegRight dneg r =
--   |> rel r (x * d) (y * d)
--   <> rel r (d * x) (d * y) =.= pairMultCommutative
--   <> rel r y       x       ... solveMultNegLeft dneg
--
-- ||| We can solve (in)equalities, with one side a multiplication
-- ||| with a positive number and the other equalling zero.
-- |||
-- ||| ```idris example
-- ||| |> 0 < x * y
-- ||| <> 0 < x     ... solveMultPosRightZero ygt0
-- ||| ```
-- export
-- 0 solveMultPosRightZero :  {x,y : Integer}
--                         -> 0 < y
--                         -> Rel r 0 x
--                         -> r 0 (x * y)
--                         -> r 0 x
-- solveMultPosRightZero pos r =
--   |> rel r 0 (x * y)
--   <> rel r (0 * y) (x * y) ~.. multZeroLeftAbsorbs
--   <> rel r 0 x             ... solveMultPosRight pos
--
-- ||| We can solve (in)equalities, with one side a multiplication
-- ||| with a negative number and the other equalling zero.
-- |||
-- ||| ```idris example
-- ||| |> 0 < x * y
-- ||| <> x < 0     ... solveMultNegRightZero ylt0
-- ||| ```
-- export
-- 0 solveMultNegRightZero :  {x,y : Integer}
--                         -> y < 0
--                         -> Rel r x 0
--                         -> r 0 (x * y)
--                         -> r x 0
-- solveMultNegRightZero negate r =
--   |> rel r 0 (x * y)
--   <> rel r (0 * y) (x * y) ~.. multZeroLeftAbsorbs
--   <> rel r x 0             ... solveMultNegRight negate
--
-- ||| We can solve (in)equalities, with one side a multiplication
-- ||| with a positive number and the other equalling zero.
-- |||
-- ||| ```idris example
-- ||| |> 0 < x * y
-- ||| <> 0 < y     ... solveMultPosLeftZero xgt0
-- ||| ```
-- export
-- 0 solveMultPosLeftZero :  {x,y : Integer}
--                         -> 0 < x
--                         -> Rel r 0 y
--                         -> r 0 (x * y)
--                         -> r 0 y
-- solveMultPosLeftZero pos r =
--   |> rel r 0 (x * y)
--   <> rel r (x * 0) (x * y) ~.. multZeroRightAbsorbs
--   <> rel r 0 y             ... solveMultPosLeft pos
--
-- ||| We can solve (in)equalities, with one side a multiplication
-- ||| with a negative number and the other equalling zero.
-- |||
-- ||| ```idris example
-- ||| |> 0 < x * y
-- ||| <> y < 0     ... solveMultNegLeftZero xlt0
-- ||| ```
-- export
-- 0 solveMultNegLeftZero :  {x,y : Integer}
--                         -> x < 0
--                         -> Rel r y 0
--                         -> r 0 (x * y)
--                         -> r y 0
-- solveMultNegLeftZero negate r =
--   |> rel r 0 (x * y)
--   <> rel r (x * 0) (x * y) ~.. multZeroRightAbsorbs
--   <> rel r y 0             ... solveMultNegLeft negate
--
-- ||| We can solve (in)equalities, with one side a multiplication
-- ||| with a positive number and the other equalling the positive
-- ||| number.
-- |||
-- ||| ```idris example
-- ||| |> y < x * y
-- ||| <> 1 < x     ... solveMultPosRightSelf ygt0
-- ||| ```
-- export
-- 0 solveMultPosRightSelf :  {x,y : Integer}
--                         -> 0 < y
--                         -> Rel r 1 x
--                         -> r y (x * y)
--                         -> r 1 x
-- solveMultPosRightSelf pos r =
--   |> rel r y (x * y)
--   <> rel r (1 * y) (x * y) ~.. multOneLeftNeutral
--   <> rel r 1 x             ... solveMultPosRight pos
--
-- ||| We can solve (in)equalities, with one side a multiplication
-- ||| with a positive number and the other equalling the positive
-- ||| number.
-- |||
-- ||| ```idris example
-- ||| |> x < x * y
-- ||| <> 1 < y     ... solveMultPosLeftSelf xgt0
-- ||| ```
-- export
-- 0 solveMultPosLeftSelf :  {x,y : Integer}
--                        -> 0 < x
--                        -> Rel r 1 y
--                        -> r x (x * y)
--                        -> r 1 y
-- solveMultPosLeftSelf pos r =
--   |> rel r x (x * y)
--   <> rel r (x * 1) (x * y) ~.. multOneRightNeutral
--   <> rel r 1 y             ... solveMultPosLeft pos
--
-- ||| We can solve (in)equalities, with one side a multiplication
-- ||| with a negative number and the other equalling the negative
-- ||| number.
-- |||
-- ||| ```idris example
-- ||| |> y < x * y
-- ||| <> x < 1     ... solveMultNegRightSelf ylt0
-- ||| ```
-- export
-- 0 solveMultNegRightSelf :  {x,y : Integer}
--                         -> y < 0
--                         -> Rel r x 1
--                         -> r y (x * y)
--                         -> r x 1
-- solveMultNegRightSelf negate r =
--   |> rel r y (x * y)
--   <> rel r (1 * y) (x * y) ~.. multOneLeftNeutral
--   <> rel r x 1             ... solveMultNegRight negate
--
-- ||| We can solve (in)equalities, with one side a multiplication
-- ||| with a negative number and the other equalling the negative
-- ||| number.
-- |||
-- ||| ```idris example
-- ||| |> x < x * y
-- ||| <> y < 1     ... solveMultNegLeftSelf xlt0
-- ||| ```
-- export
-- 0 solveMultNegLeftSelf :  {x,y : Integer}
--                         -> x < 0
--                         -> Rel r y 1
--                         -> r x (x * y)
--                         -> r y 1
-- solveMultNegLeftSelf negate r =
--   |> rel r x (x * y)
--   <> rel r (x * 1) (x * y) ~.. multOneRightNeutral
--   <> rel r y 1             ... solveMultNegLeft negate
--
-- --------------------------------------------------------------------------------
-- --          Division
-- --------------------------------------------------------------------------------
--
-- export
-- 0 multDivP1 : {n,d : Integer} -> (0 < d) -> d * (div n d + 1) > n
-- multDivP1 dpos = App (snd $ modLT n d dpos) $
--   |> mod n d               < d
--   <> d * div n d + mod n d < d * div n d + d ... plusLeft
--   <> n < d * (div n d + 1)                   =.= (
--        lawDivMod n d %search
--      , solve [n,d,div n d] (d .*. div n d +. d)
--                            (d .* (div n d .+ 1))
--      )
--
-- export
-- 0 multDiv : {n,d : Integer} -> (0 < d) -> d * div n d <= n
-- multDiv dpos = App (fst $ modLT n d dpos) $
--   |> 0 <= mod n d
--   <> d * div n d + 0 <= d * div n d + mod n d ... plusLeft
--   <> d * div n d     <= n                     =.= (
--        plusZeroRightNeutral
--      , lawDivMod n d %search
--      )
--
-- export
-- 0 divNonNeg : {n,d : Integer} -> (0 <= n) -> (0 < d) -> 0 <= div n d
-- divNonNeg ngte0 dpos = App (trans_GT_GTE (multDivP1 dpos) ngte0) $
--   |> 0     <  d * (div n d + 1)
--   <> 0     <  div n d + 1       ... solveMultPosLeftZero dpos
--   <> 1     <= div n d + 1       ... (\_ => oneAfterZero _)
--   <> 0     <= div n d           ... solvePlusRightSelf
--
-- export
-- 0 modLTE : {n,d : Integer} -> (0 <= n) -> (0 < d) -> mod n d <= n
-- modLTE ngte0 dpos = App (divNonNeg ngte0 dpos) $
--   |> 0               <= div n d
--   <> d * 0           <= d * div n d           ... multPosLeft dpos
--   <> d * 0 + mod n d <= d * div n d + mod n d ... plusRight
--   <> mod n d         <= n                     =.= (
--        solve [d, mod n d] (d .* 0 +. mod n d) (var (mod n d))
--      , lawDivMod n d %search
--      )
--
-- export
-- 0 modOneIsZero : {n : Integer} -> mod n 1 === 0
-- modOneIsZero = assert_total $ case comp (mod n 1) 0 of
--   EQ _ p _ => p
--   LT p _ _ => void (LT_not_GTE p $ fst $ modLT n 1 %search)
--   GT _ _ p => void (LT_not_GTE (snd $ modLT n 1 %search) (oneAfterZero _ p))
--
-- export
-- 0 divOneSame : {n : Integer} -> div n 1 === n
-- divOneSame = assert_total $ Calc $
--   |~ div n 1
--   ~~ 1 * div n 1           ..< multOneLeftNeutral
--   ~~ 1 * div n 1 + 0       ..< plusZeroRightNeutral
--   ~~ 1 * div n 1 + mod n 1 ..< cong (1 * div n 1 +) modOneIsZero
--   ~~ n                     ... lawDivMod n 1 %search
--
-- export
-- 0 divGreaterOneLT : {n,d : Integer} -> 0 < n -> 1 < d -> div n d < n
-- divGreaterOneLT npos dgt1 =
--   let dpos = the (0 < d) $ trans %search dgt1
--    in assert_total $ case comp 0 (div n d) of
--        EQ _ p _ => replace {p = (< n)} p npos
--        LT p _ _ => App dgt1 $
--          |> 1 < d
--          <> 1 * div n d < d * div n d ... multPosRight p
--          <> div n d     < d * div n d =.. multOneLeftNeutral
--          <> div n d     < n           ... (\_ => trans_GTE_GT $ multDiv dpos)
--        GT _ _ p => void (LT_not_GTE p $ divNonNeg %search dpos)
--
-- export
-- 0 divPos : {n,d : Integer} -> (d <= n) -> (0 < d) -> 0 < div n d
-- divPos dn dp = assert_total $ case comp 0 (div n d) of
--   LT p _ _ => p
--   EQ _ p _ =>
--     let modIsN = Calc $
--           |~ mod n d
--           ~~ 0 + mod n d             ..< plusZeroLeftNeutral
--           ~~ (d * 0) + mod n d       ..< cong (+ mod n d) multZeroRightAbsorbs
--           ~~ (d * div n d) + mod n d ... cong (\x => (d * x) + mod n d) p
--           ~~ n                       ... lawDivMod n d (Right dp)
--      in void (LTE_not_GT dn $ rewrite sym modIsN in snd (modLT n d dp))
--   GT _ _ p => void (GT_not_LTE p (divNonNeg (Left $ trans_LT_LTE dp dn) dp))
